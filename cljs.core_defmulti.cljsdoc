===== Example#375504

```
;; Define the multimethod
(defmulti service-charge (fn [acct] [(account-level acct) (:tag acct)]))

;; Handlers for resulting dispatch values
(defmethod service-charge [::acc/Basic ::acc/Checking]   [_] 25)
(defmethod service-charge [::acc/Basic ::acc/Savings]    [_] 10)
(defmethod service-charge [::acc/Premium ::acc/Account] [_] 0)
```

===== Example#375504

```
;this example illustrates that the dispatch type
;does not have to be a symbol, but can be anything (in this case, it's a string)

(defmulti greeting
  (fn[x] (x "language")))

;params is not used, so we could have used [_]
(defmethod greeting "English" [params]
 "Hello!")

(defmethod greeting "French" [params]
 "Bonjour!")

;;default handling
(defmethod greeting :default [params]
 (throw (IllegalArgumentException. 
          (str "I don't know the " (params "language") " language"))))

;then can use this like this:
(def english-map {"id" "1", "language" "English"})
(def  french-map {"id" "2", "language" "French"})
(def spanish-map {"id" "3", "language" "Spanish"})

=>(greeting english-map)
"Hello!"
=>(greeting french-map)
"Bounjour!"
=>(greeting spanish-map)
 java.lang.IllegalArgumentException: I don't know the Spanish language
```

===== Example#375504

```
;; Implementing factorial using multimethods Note that factorial-like function 
;; is best implemented using `recur` for enable tail-call optimization to avoid 
;; stack overflow error. This is a only a demonstration of clojure's multimethod

;; identity form returns the same value passed
(defmulti factorial identity)

(defmethod factorial 0 [_]  1)
(defmethod factorial :default [num] 
    (* num (factorial (dec num))))

(factorial 0) ; => 1
(factorial 1) ; => 1
(factorial 3) ; => 6
(factorial 7) ; => 5040
```

===== Example#375504

```
;; defmulti/defmethods support variadic arguments and dispatch functions.

(defmulti bat 
  (fn ([x y & xs] 
       (mapv class (into [x y] xs)))))
(defmethod bat [String String] [x y & xs] 
  (str "str: " x " and " y))
(defmethod bat [String String String] [x y & xs] 
  (str "str: " x ", " y " and " (first xs)))
(defmethod bat [String String String String] [x y & xs] 
  (str "str: " x ", " y ", " (first xs) " and " (second xs)))
(defmethod bat [Number Number] [x y & xs] 
  (str "number: " x " and " y))

;; you call it like this...

(bat "mink" "stoat")
;; => "str: mink and stoat"

(bat "bear" "skunk" "sloth")
;; => "str: bear, skunk and sloth"

(bat "dog" "cat" "cow" "horse")
;; => "str: dog, cat, cow and horse"

(bat 1 2)
;; => "number: 1 and 2"
```

===== Example#375504

```
;; defmulti - custom hierarchy

(def h (-> (make-hierarchy)
           (derive :foo :bar)))

(defmulti f identity :hierarchy #'h) ;; hierarchy must be a reference type

(defmethod f :default [_] "default")
(defmethod f :bar [_] "bar")

(f :unknown) ;; "default"
(f :bar) ;; "bar"
(f :foo) ;; "bar"
```
