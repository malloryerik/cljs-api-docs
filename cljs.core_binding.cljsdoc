===== Example#c32620

```
;; Here are the definitions.
(defn mymax [x y]
  (min x y))

(defn find-max [x y]
  (max x y))

user=> (let [max mymax]
         (find-max 10 20))

20 ;let is ineffective outside current lexical scope


user=> (binding [max mymax]
         (find-max 10 20))

10 ;because max is now acting as min
```

===== Example#c32620

```
;; As of Clojure 1.3, vars need to be explicitly marked as ^:dynamic in order for
;; them to be dynamically rebindable:

user=> (def ^:dynamic x 1)
user=> (def ^:dynamic y 1)
user=> (+ x y)
2

;; Within the scope of the binding, x = 2 and y = 3

user=> (binding [x 2 y 3]
         (+ x y))
5

;; But once you leave the binding's scope, x and y maintain their original
;; bindings:

user=> (+ x y)
2
```

===== Example#c32620

```
;;Use t like a "template"

(declare ^:dynamic t)

(defn addt [] 
  (+ t 10))

(binding [t 1]
  (addt))
=> 11
```

===== Example#c32620

```
; You can set! bindings. Useful in a stateful programming.
user=> (def ^:dynamic d)
#'user/d
user=> d
#<Unbound Unbound: #'user/d>
user=> (binding [d 0] (prn d) (set! d 1) (prn d))
0
1
nil
user=> d
#<Unbound Unbound: #'user/d>
```

===== Example#c32620

```
; Speed test. recur is the preferred way.
user=> (def a (atom 0))
#'user/a
user=> (def ^:dynamic b)
#'user/b
user=> (def d)
#'user/d
user=> (time (loop [r 0] (when (< r 10000000) (recur (inc r)))))
"Elapsed time: 8.062612 msecs"
nil
user=> (time (dotimes [_ 10000000] (reset! a 1)))
"Elapsed time: 93.428704 msecs"
nil
user=> (time (binding [b 0] (dotimes [_ 10000000] (set! b 1))))
"Elapsed time: 484.331821 msecs"
nil
user=> (time (with-local-vars [w 0] (dotimes [_ 10000000] (var-set w 1))))
"Elapsed time: 490.598696 msecs"
nil
user=> (time (dotimes [_ 10000000] (def d 1)))
"Elapsed time: 2154.646688 msecs"
nil

```
