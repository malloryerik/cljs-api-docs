===== Example#8b23ee

```
;; The commented forms do not get executed
user=> (comment
         (functioncall-1)
         (functioncall-2))
nil
```

===== Example#f17a56

```
;; What is inside the (comment ...) form is not completely ignored.  Clojure
;; still tries to use the normal reader to read it, so it must consist of
;; a sequence of readable forms with balanced parens, braces, square brackets,
;; with no unreadable elements.

;; If you want lines to be completely ignored, you must use a ; to comment from
;; the ; until the end of the line.  If you want to quickly comment or uncomment
;; a range of consecutive lines, most text editors have special commands
;; specifically for that.  e.g. Emacs has comment-region
;; http://www.gnu.org/software/emacs/manual/html_node/emacs/Comment-Commands.html
;; Vim has visual commands to do this, and probably many other text editors.
;; (Feel free to edit this text to add links to docs for other editors).

;; What is inside the (commment ...) is readable, so no error for this,
;; and no code will be generated by the compiler.
(comment
(defn foo [x]
  (inc x))
)

;; What is inside the (comment ...) is NOT readable, so this will give an error
(comment
a : b
)
```

===== Example#747479

```
;; Another thing to watch out for: the comment form IS a form, and is usually
;; the wrong way to comment out code.  For example, let's say that you want to
;; try out a new "then" form in an "if":
(if true (comment :old-then) :new-then)  ;;=> nil (Oops, :new-then was desired.)

;; Instead, use the "ignore next form" reader macro #_:
(if true #_(:old-then) :new-then)  ;;=> :new-then

;; Note that #_ also allows non-readable code:
#_(a : b) 1  ;;=> 1 (contrast to (comment a : b) which doesn't compile.)

```
