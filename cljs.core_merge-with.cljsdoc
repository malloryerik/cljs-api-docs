===== Example#f7bbcf

```
(merge-with concat
	  {"Lisp" ["Common Lisp" "Clojure"]
	   "ML" ["Caml" "Objective Caml"]}
	  {"Lisp" ["Scheme"]
	   "ML" ["Standard ML"]})
;;=> {"Lisp" ("Common Lisp" "Clojure" "Scheme"), "ML" ("Caml" "Objective Caml" "Standard ML")}

(clojure.pprint/pp)
;; {"Lisp" ("Common Lisp" "Clojure" "Scheme"), "ML" ("Caml" "Objective Caml" "Standard ML")}
;;=> nil

```

===== Example#f7bbcf

```
;; merge two maps using the addition function

(merge-with + 
            {:a 1  :b 2}
            {:a 9  :b 98 :c 0})   
;;=> {:c 0, :a 10, :b 100}
```

===== Example#f7bbcf

```
;; 'merge-with' works with an arbitrary number of maps:

(merge-with + 
           {:a 1  :b 2}
           {:a 9  :b 98  :c 0}
           {:a 10 :b 100 :c 10}
           {:a 5}
           {:c 5  :d 42})
    
;;=> {:d 42, :c 15, :a 25, :b 200}
```

===== Example#f7bbcf

```
;; Use union to merge sets of elements
(use 'clojure.set)
(merge-with union
            {:a #{1 2 3},   :b #{4 5 6}}
            {:a #{2 3 7 8}, :c #{1 2 3}})

;;=> {:c #{1 2 3}, :a #{1 2 3 7 8}, :b #{4 5 6}}
```

===== Example#f7bbcf

```
;; Demonstrating difference between merge and merge-with

;; For merge the value from the right-most map wins:
(merge {:a 1} {:a 2} {:a 3})
;;=> {:a 3}

;; while for merge-with values are merged (with function + in this example):
(merge-with + {:a 1} {:a 2} {:a 3})
;;=> {:a 6}
```

===== Example#f7bbcf

```
;; Use merge-with and merge to merge values that are one level deep maps.

(merge-with merge {:x {:y 1}} {:x {:z 2}})
;;=> {:x {:z 2, :y 1}}

;; Deeper maps are not merged:
(merge-with merge {:x {:y {:a 1}}} {:x {:y {:b 2}}})
;;=>{:x {:y {:b 2}}}
```
