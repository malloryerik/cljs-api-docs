===== Example#aa1c1b

```
user=> (keep-indexed #(if (odd? %1) %2) [:a :b :c :d :e])
(:b :d)
```

===== Example#aa1c1b

```
user=> (keep-indexed #(if (pos? %2) %1) [-9 0 29 -7 45 3 -8])
(2 4 5)
;; f takes 2 args: 'index' and 'value' where index is 0-based
;; when f returns nil the index is not included in final result
user=> (keep-indexed (fn [idx v]
                       (if (pos? v) idx)) [-9 0 29 -7 45 3 -8])
(2 4 5)
```

===== Example#aa1c1b

```
(defn position [x coll & {:keys [from-end all] :or {from-end false all false}}]
  (let [all-idxs (keep-indexed (fn [idx val] (when (= val x) idx)) coll)]
  (cond
   (true? from-end) (last all-idxs)
   (true? all)      all-idxs
   :else            (first all-idxs))))

user> (position [1 1] [[1 0][1 1][2 3][1 1]])
1
user> (position [1 1] [[1 0][1 1][2 3][1 1]] :from-end true)
3
user> (position [1 1] [[1 0][1 1][2 3][1 1]] :all true)
(1 3)

user> (def foo (shuffle (range 10)))
#'user/foo
user> foo
(5 8 9 1 2 7 0 6 3 4)
user> (position 5 foo)
0
user> (position 0 foo)
6
```
