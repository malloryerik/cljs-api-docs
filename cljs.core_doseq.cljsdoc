===== Example#922545

```
user=> (doseq [x [1 2 3] 
               y [1 2 3]] 
         (prn (* x y)))
1
2
3
2
4
6
3
6
9
nil

```

===== Example#774aef

```
user=> (doseq [[x y] (map list [1 2 3] [1 2 3])] 
         (prn (* x y)))
1
4
9
nil

;; where
user=> (map list [1 2 3] [1 2 3])
((1 1) (2 2) (3 3))
```

===== Example#3ad331

```
user=> (doseq [[[a b] [c d]] (map list (sorted-map :1 1 :2 2) (sorted-map :3 3 :4 4))]
         (prn (* b d)))
3
8
nil

;; where
user=> (map list (sorted-map :1 1 :2 2) (sorted-map :3 3 :4 4))
(([:1 1] [:3 3]) ([:2 2] [:4 4]))
```

===== Example#e54e21

```
user=> (doseq [[k v] (map identity {:1 1 :2 2 :3 3})] 
         (prn k v))
:1 1
:2 2
:3 3
nil

;; where
user=> (map identity {:1 1 :2 2 :3 3})
([:1 1] [:2 2] [:3 3])

;; or simply
user=> (doseq [[k v] {:1 1 :2 2 :3 3}]
         (prn k v))
:1 1
:3 3
:2 2
nil
```

===== Example#b2acd7

```
; Multiple sequences results in a Cartesian cross of their values.
user=> (doseq [a [1 2]
               b [3 4]]
         (println a b))
1 3
1 4
2 3
2 4
nil
```

===== Example#b1ee0c

```
; Keywords :let, :when, and :while are supported, the same as "for"
user=> (doseq [x (range 6)
               :when (odd? x)
               :let [y (* x x)] ]
         (println [x y]) )
[1 1]
[3 9]
[5 25]
nil
user=> (doseq [x (range 99)
               :let [y (* x x)] 
               :while (< y 30)
              ]
         (println [x y]) )
[0 0]
[1 1]
[2 4]
[3 9]
[4 16]
[5 25]
nil
user=> 

```

===== Example#dff797

```
; ClojureCLR example
; Prints names of running processes

user=> (doseq [x (System.Diagnostics.Process/GetProcesses)] 
              (println (.get_ProcessName x)))
avgnt
SearchIndexer
svchost
chrome
audiodg
svchost
mbamscheduler
spoolsv
nvxdsync
avwebg7
GoogleCrashHandler64
svchost
CCleaner64
ViakaraokeSrv
...
```
